<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sourcerer Ludi</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', Courier, monospace;
            background: #fff;
            color: #000;
            padding: 20px;
            line-height: 1.4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            border-bottom: 4px solid #000;
            padding-bottom: 15px;
        }

        h1 {
            font-size: 2.8em;
            letter-spacing: 4px;
            color: #000;
            margin-bottom: 5px;
            font-weight: 900;
            text-transform: uppercase;
        }

        .subtitle {
            color: #000;
            font-size: 1em;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: bold;
        }

        .state-panel {
            background: #f0f0f0;
            border: 4px solid #000;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .state-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="text"] {
            padding: 8px;
            border: 3px solid #000;
            font-family: inherit;
            flex-grow: 1;
        }

        .saved-states-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .state-chip {
            padding: 4px 10px;
            background: #fff;
            border: 2px solid #000;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .state-chip button {
            padding: 1px 5px;
            border-width: 1px;
            font-size: 0.7em;
        }

        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .draw-options {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8em;
            border-left: 2px solid #000;
            padding-left: 15px;
            cursor: pointer;
        }

        .draw-options input { cursor: pointer; }

        button {
            background: #fff;
            color: #000;
            border: 3px solid #000;
            padding: 8px 16px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9em;
            font-weight: 900;
            transition: all 0.1s;
            text-transform: uppercase;
        }

        button:hover {
            background: #000;
            color: #fff;
            box-shadow: 4px 4px 0 #000;
            transform: translate(-2px, -2px);
        }

        button:active {
            transform: translate(0, 0);
            box-shadow: none;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1em;
            font-weight: bold;
            border: 2px solid #000;
            display: inline-block;
            padding: 5px 20px;
            left: 50%;
            position: relative;
            transform: translateX(-50%);
        }

        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            padding: 20px;
            min-height: 400px;
        }

        .card-container {
            position: relative;
            transition: margin 0.3s ease;
        }

        .card {
            background: #fff;
            border: 4px solid #000;
            padding: 15px;
            width: 200px;
            height: 280px;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.2s;
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 6px 6px 0 #000;
            user-select: none;
        }

        .card.is-flipped { background: #000; color: #fff; }
        .card.is-flipped .card-content { display: none; }
        .card-back-suit {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            font-weight: 900;
            text-align: center;
            border: 2px solid #fff;
            padding: 10px;
            width: 85%;
        }
        .card.is-flipped .card-back-suit { display: block; }
        .card.selected { outline: 6px solid #aaa; outline-offset: 4px; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 3px solid #000;
        }

        .card-suit { font-weight: 900; font-size: 1.1em; }
        .card-label { font-weight: 900; font-size: 1.2em; margin-bottom: 10px; text-transform: uppercase; }
        .card-desc { font-size: 0.8em; flex-grow: 1; }

        .card-position {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            justify-content: center;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }

        .pos-dot {
            width: 14px;
            height: 14px;
            background: #fff;
            border: 2px solid #000;
            border-radius: 2px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .pos-dot:hover { background: #eee; }
        .pos-dot.active { background: #000; box-shadow: inset 0 0 0 2px #fff; }

        .card-menu {
            position: absolute;
            top: 0; left: 100%; margin-left: 15px; z-index: 100;
            background: #fff; border: 4px solid #000; padding: 5px;
            display: flex; flex-direction: column; gap: 5px; box-shadow: 4px 4px 0 #000; width: 160px;
        }
        .card-menu button { border: 1px solid #000; padding: 5px; font-size: 0.7em; text-align: left; width: 100%; color: #000; }

        .modal {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95); padding: 30px; overflow-y: auto; z-index: 1000;
        }
        .modal-content { max-width: 900px; margin: 0 auto; background: #fff; padding: 40px; border: 8px solid #000; }

        .stack-select-item {
            padding: 10px;
            border: 2px solid #000;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
        }
        .stack-select-item:hover { background: #000; color: #fff; }

        /* Survey & About Styles */
        .survey-grid {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 20px 0;
        }
        .survey-row {
            border: 4px solid #000;
            padding: 20px;
            background: #fafafa;
        }
        .survey-row-title {
            font-weight: 900;
            font-size: 1.2em;
            margin-bottom: 15px;
            text-transform: uppercase;
            display: block;
            border-bottom: 2px solid #000;
            padding-bottom: 5px;
        }
        .survey-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
        }
        .survey-option {
            padding: 12px;
            border: 2px solid #000;
            font-size: 0.85em;
            cursor: pointer;
            background: #fff;
            display: flex;
            flex-direction: column;
            gap: 4px;
            transition: all 0.1s;
        }
        .survey-option:hover { background: #eee; }
        .survey-option.active { background: #000; color: #fff; border-color: #000; }
        .survey-option-label { font-weight: 900; text-transform: uppercase; font-size: 1em; }
        .survey-option-desc { font-size: 0.8em; opacity: 0.8; }

        .about-text h3 {
            margin-top: 25px;
            margin-bottom: 10px;
            border-bottom: 2px solid #000;
            display: inline-block;
        }
        .about-text p { margin-bottom: 15px; font-size: 0.95em; }
        .about-text ul { margin-bottom: 15px; padding-left: 20px; list-style: square; }
        .about-text li { margin-bottom: 8px; }
        .about-text a { color: #000; font-weight: 900; text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>SOURCERER LUDI</h1>
            <div class="subtitle">A Map of Conscious Experience</div>
        </header>

        <div class="state-panel">
            <div class="state-controls">
                <input type="text" id="state-name" placeholder="NAME CURRENT CONFIGURATION...">
                <button onclick="game.saveState()">SAVE STATE</button>
            </div>
            <div id="saved-states-list" class="saved-states-list"></div>
        </div>

        <div class="controls">
            <button onclick="game.drawCard()" id="draw-btn">DRAW</button>
            <div class="draw-options">
                <input type="checkbox" id="reveal-draw"> <label for="reveal-draw">REVEAL ON DRAW</label>
            </div>
            <button onclick="game.autoWin()">COHERE</button>
            <button onclick="showSurveyModal()">SURVEY</button>
            <button onclick="showAboutModal()">ABOUT</button>
            <button onclick="game.newGame()">RESET</button>
        </div>

        <div class="status">
            <span id="hand-status">HAND: 0</span> | <span id="deck-status">DECK: 0</span>
        </div>

        <div id="hand" class="hand"></div>
    </div>

    <div id="stack-modal" class="modal">
        <div class="modal-content">
            <h2>STACK WITH...</h2>
            <div id="stack-list"></div>
            <button onclick="hideStackModal()" style="width:100%; margin-top:20px;">CANCEL</button>
        </div>
    </div>

    <div id="survey-modal" class="modal">
        <div class="modal-content">
            <h2>OBSERVATION SURVEY</h2>
            <p style="font-size: 0.8em; margin-bottom: 20px;">Identify your current coordinates. Unselected dimensions will remain unknown (face-down).</p>
            <div id="survey-grid" class="survey-grid"></div>
            <div style="display: flex; gap: 10px;">
                <button onclick="game.commitSurvey()" style="flex: 2; background: #000; color: #fff;">COMMIT STATE</button>
                <button onclick="hideSurveyModal()" style="flex: 1;">CANCEL</button>
            </div>
        </div>
    </div>

    <div id="about-modal" class="modal">
        <div class="modal-content about-text">
            <h3>EXPERIENTIAL EMPIRICISM (EE)</h3>
            <p>All evidence is present experience. Time as well as space and matter are all patterns within experience, attributes of the present experiential moment. You cannot use experience to prove something outside it: that’s circular, assuming the conclusion. Experience and logic are ALL that survive burden of proof.</p>
            <p>Where appropriate I call this new field Sourcery, as EE provides access to the shared ground under philosophy and science by dissolving the subject/object divide.</p>
            <p>This is the polar opposite of eliminative materialism. Instead of absurdly saying my experiences don’t exist, which is axiomatically false since I’m having one while saying it, I simply stick with only that which is self-proving: <strong>Experience and logic.</strong></p>

            <h3>THE MAGIC WINDOW</h3>
            <p>The Magic Window is a thought experiment demonstrating that the problem of "external reality" is logical, not sensory. Imagine a device that bypasses all sensory organs and inserts perfect, direct knowledge of mind-independent material reality into your consciousness. Even in this scenario, your verification of that reality remains an experiential event. You are still looking at patterns within consciousness.</p>
            <p>This reveals that no possible operation can verify a non-experiential cause without that verification being experiential itself. Accessing "external reality" would only ever provide more experiential patterns, making the materialist interpretation an explanatorily idle story added onto the patterns we already have.</p>
            <p>Why posit a metaphysical external that does no work beyond adding confusion? Patterns of experience alone are exhaustively sufficient. We don’t also need stories about the patterns. People keep assuming events sit in a container (space, time, thought, god, simulation), despite all evidence of the container being more present self-contained experience. Formally make experience the axiom, skip the middle men, and watch the problems vanish.</p>

            <h3>THE AXOMATIC FRAMEWORK</h3>
            <p>EE applies burden of proof ruthlessly. This eliminates materialism, external time, and spatial externality as unjustified assumptions. What remains are two self-proving axioms:</p>
            <ul>
                <li><strong>Experience exists:</strong> proven by occurring.</li>
                <li><strong>Logic works:</strong> proven by use.</li>
            </ul>
            <p>Physical laws describe experiential regularities, not hidden substances. Problems like consciousness, quantum measurement, and free will dissolve as artifacts of the discarded externalist assumption. Science requires no methodological changes because it was always mapping experiential patterns.</p>

            <h3>THE SELF-CONTAINED VIEW</h3>
            <ul>
                <li><strong>Metaphysics:</strong> Only experiential moments, with time and space as structural features within them.</li>
                <li><strong>Epistemology:</strong> Justified by occurrence (experience) and coherence (logic-in-use).</li>
                <li><strong>Ethics:</strong> Managed by navigating and shaping valence patterns.</li>
                <li><strong>Science:</strong> Describes stable, recurrent experiential correlations.</li>
            </ul>
            <p>Regularity is just what’s given. Positing an unseen cause for it is both circular and superfluous. I limit my system to the fewest number of axioms possible for the same reason I respect burden of proof and parsimony.</p>
            <p>The only remaining problem is proving other minds feel things, which cannot be done, but that is operationally irrelevant because clearly they exist as sources of experience patterns. I choose not to be cruel. That’s the logical and phenomenological ground zero of any possible epistemology.</p>
            <p>To reject it is to step outside the possibility of having a view at all.</p>

            <p style="margin-top:20px; font-size: 0.8em; border-top: 1px dashed #000; padding-top:10px;">
                Based on the work more fully explored here: <a href="https://philpeople.org/profiles/brandon-sergent/publications" target="_blank">Brandon Sergent Publications</a>
            </p>

            <button onclick="hideAboutModal()" style="width:100%; margin-top:20px; background: #000; color: #fff;">CLOSE</button>
        </div>
    </div>

    <script>
    const LUDI_MODEL = {
            dimensions: [
                { id: 'I', suit: 'IDENTITY', question: 'What are you right now?' },
                { id: 'M', suit: 'MENTALITY', question: "How's your thinking?" },
                { id: 'F', suit: 'FOCUS', question: "How's your focus?" },
                { id: 'A', suit: 'AFFECT', question: 'How do you feel?' },
                { id: 'S', suit: 'SENSORY', question: 'Is any specific sense overwhelming?' },
                { id: 'T', suit: 'TEMPORAL', question: "What's time doing?" }
            ],
            cards: [
                {dim: 'I', val: 0.00, label: 'Agent', desc: 'Initiator and author of experience. (executive, commanding, sovereign, lucid-meta)'},
                {dim: 'I', val: 0.17, label: 'Passenger', desc: 'Recipient of experience, no control. (helpless, determined, swept-along, NPC)'},
                {dim: 'I', val: 0.33, label: 'Witness', desc: 'Observing experience from a step back. (spectating, detached, watching, metacognitive)'},
                {dim: 'I', val: 0.50, label: 'Performer', desc: 'Playing a role or presenting a self. (masking, acting, persona, social-self)'},
                {dim: 'I', val: 0.67, label: 'Embodied', desc: 'Living primarily as the body. (somatic, proprioceptive, sensorimotor, body-identified)'},
                {dim: 'I', val: 0.83, label: 'Fragmented', desc: 'Self-sense broken into parts. (dissociated, multiple, split, conflicted)'},
                {dim: 'I', val: 1.00, label: 'Dissolved', desc: 'No clear self-other boundary. (boundaryless, merged, oceanic, non-dual)'},

                {dim: 'M', val: 0.00, label: 'Silent', desc: 'Absence of verbal thought activity. (thoughtless, pre-verbal, empty)'},
                {dim: 'M', val: 0.17, label: 'Verbal', desc: 'Thinking structured by language. (monologue, dialogue, linguistic)'},
                {dim: 'M', val: 0.33, label: 'Imagistic', desc: 'Thinking through images and scenes. (visual, spatial, scenic)'},
                {dim: 'M', val: 0.50, label: 'Conceptual', desc: 'Abstract ideas without sensory content. (analytical, philosophical, theoretical)'},
                {dim: 'M', val: 0.67, label: 'Associative', desc: 'Rapid free-flowing thought connections. (creative, tangential, lateral)'},
                {dim: 'M', val: 0.83, label: 'Recursive', desc: 'Thoughts about thoughts, looping back. (meta-cognitive, self-referential, circular)'},
                {dim: 'M', val: 1.00, label: 'Intuitive', desc: 'Direct knowing without reasoning process. (felt-sense, non-rational, immediate)'},

                {dim: 'F', val: 0.00, label: 'Diffuse', desc: 'Unfocused awareness of whole field. (ambient, scattered, panoramic)'},
                {dim: 'F', val: 0.17, label: 'Narrow', desc: 'Concentrated on single point or object. (single-pointed, absorbed, tunneled)'},
                {dim: 'F', val: 0.33, label: 'Divided', desc: 'Genuinely attending multiple streams. (multi-tracked, split, parallel)'},
                {dim: 'F', val: 0.50, label: 'Scanning', desc: 'Rapidly shifting between targets. (searching, vigilant, restless)'},
                {dim: 'F', val: 0.67, label: 'Peripheral', desc: 'Focused on edges rather than center. (background-attentive, marginal, ambient-detail)'},
                {dim: 'F', val: 0.83, label: 'Captured', desc: 'Involuntarily held by specific content. (fascinated, stuck, compelled)'},
                {dim: 'F', val: 1.00, label: 'Oscillating', desc: 'Regular rhythm of engagement and release. (fluctuating, cycling, pulsing)'},

                {dim: 'A', val: 0.00, label: 'Elevated', desc: 'Positive affective expansion. (bliss, joy, excitement, elation)'},
                {dim: 'A', val: 0.17, label: 'Peaceful', desc: 'Calm positive settledness. (content, serene, satisfied, tranquil)'},
                {dim: 'A', val: 0.33, label: 'Neutral', desc: 'Neither pleasant nor unpleasant quality. (equanimous, flat, indifferent)'},
                {dim: 'A', val: 0.50, label: 'Tense', desc: 'Uncomfortable activation and worry. (anxious, agitated, stressed, unsettled)'},
                {dim: 'A', val: 0.67, label: 'Heavy', desc: 'Downward affective weight. (sad, grieving, depressed, collapsed)'},
                {dim: 'A', val: 0.83, label: 'Aversive', desc: 'Active resistance and repulsion. (angry, irritated, disgusted, hostile)'},
                {dim: 'A', val: 1.00, label: 'Complex', desc: 'Multiple contradictory affects present. (bittersweet, ambivalent, mixed, layered)'},

                {dim: 'S', val: 0.00, label: 'Visual', desc: 'Sight overwhelming awareness. (color, brightness, patterns, movement, light)'},
                {dim: 'S', val: 0.17, label: 'Auditory', desc: 'Sound dominating experience. (noise, music, voices, silence, rhythm)'},
                {dim: 'S', val: 0.33, label: 'Tactile', desc: 'Touch consuming attention. (pressure, texture, contact, temperature, skin)'},
                {dim: 'S', val: 0.50, label: 'Olfactory', desc: 'Smell filling awareness. (scent, fragrance, odor, aroma)'},
                {dim: 'S', val: 0.67, label: 'Gustatory', desc: 'Taste prominent in field. (flavor, mouth-sensation, aftertaste)'},
                {dim: 'S', val: 0.83, label: 'Somatic', desc: 'Body-sensation dominant. (pain, tension, internal-feeling, proprioception, breath)'},
                {dim: 'S', val: 1.00, label: 'Synesthetic', desc: 'Multiple senses blending or competing. (cross-modal, merged, sensory-chaos)'},

                {dim: 'T', val: 0.00, label: 'Dilated', desc: 'Stretched slow-motion temporal flow. (expanded, protracted, elongated)'},
                {dim: 'T', val: 0.17, label: 'Compressed', desc: 'Rapid accelerated time-sense. (condensed, rushing, hurried)'},
                {dim: 'T', val: 0.33, label: 'Suspended', desc: 'Timeless eternal-now quality. (frozen, still, atemporal, eternal)'},
                {dim: 'T', val: 0.50, label: 'Fragmented', desc: 'Discontinuous choppy moments. (skipping, broken, episodic, stuttering)'},
                {dim: 'T', val: 0.67, label: 'Flowing', desc: 'Smooth seamless progression. (river-like, continuous, unbroken)'},
                {dim: 'T', val: 0.83, label: 'Circular', desc: 'Looping recursive temporal structure. (déjà-vu, repeating, cyclical)'},
                {dim: 'T', val: 1.00, label: 'Displaced', desc: 'Temporal focus elsewhere than now. (nostalgic, anticipated, past/future-oriented)'}
            ]
        };

        class LudiEngine {
            constructor() {
                this.hand = [];
                this.deck = [];
                this.selectedIndex = null;
                this.savedStates = JSON.parse(localStorage.getItem('ludi_v1_states') || '{}');
                this.surveyChoices = {};
                this.newGame();
            }

            newGame() {
                this.deck = [...LUDI_MODEL.cards].sort(() => Math.random() - 0.5);
                this.hand = [];
                this.selectedIndex = null;
                for (let i = 0; i < 6; i++) { this.drawCard(); }
                this.updateDisplay();
            }

            drawCard() {
                if (this.deck.length === 0) {
                    this.deck = [...LUDI_MODEL.cards].sort(() => Math.random() - 0.5);
                }

                const revealChecked = document.getElementById('reveal-draw')?.checked;
                const isFlipped = !revealChecked;

                const card = {
                    ...this.deck.pop(),
                    instanceId: Math.random().toString(36).substr(2, 9),
                    rotation: 0,
                    isFlipped: isFlipped,
                    stackedWith: null
                };
                this.hand.push(card);
                this.updateDisplay();
            }

            updateCard(id, updates) {
                this.hand = this.hand.map(c => (c.instanceId === id ? {...c, ...updates} : c));
                this.updateDisplay();
            }

            changeCardState(id, dim, val) {
                const newState = LUDI_MODEL.cards.find(c => c.dim === dim && c.val === val);
                if (newState) {
                    this.hand = this.hand.map(c => (c.instanceId === id ? {...c, ...newState} : c));
                    this.updateDisplay();
                }
            }

            autoWin() {
                const revealChecked = document.getElementById('reveal-draw')?.checked;
                const isFlipped = !revealChecked;

                this.hand = LUDI_MODEL.dimensions.map(d => {
                    const choices = LUDI_MODEL.cards.filter(c => c.dim === d.id);
                    return {
                        ...choices[Math.floor(Math.random() * choices.length)],
                        instanceId: Math.random().toString(36).substr(2, 9),
                        rotation: 0,
                        isFlipped: isFlipped,
                        stackedWith: null
                    };
                });
                this.updateDisplay();
            }

            commitSurvey() {
                const finalCards = [];
                for (const dim of LUDI_MODEL.dimensions) {
                    const val = this.surveyChoices[dim.id];

                    let template;
                    let isFlipped = false;

                    if (val !== undefined) {
                        template = LUDI_MODEL.cards.find(c => c.dim === dim.id && c.val === val);
                    } else {
                        const options = LUDI_MODEL.cards.filter(c => c.dim === dim.id);
                        template = options[Math.floor(Math.random() * options.length)];
                        isFlipped = true;
                    }

                    finalCards.push({
                        ...template,
                        instanceId: Math.random().toString(36).substr(2, 9),
                        rotation: 0,
                        isFlipped: isFlipped,
                        stackedWith: null
                    });
                }
                this.hand = finalCards;
                this.updateDisplay();
                hideSurveyModal();
            }

            saveState() {
                const name = document.getElementById('state-name').value.trim();
                if (!name) return;
                const state = this.hand.map(c => ({
                    dim: c.dim,
                    val: c.val,
                    isFlipped: c.isFlipped,
                    stackedWith: c.stackedWith,
                    rotation: c.rotation
                }));
                this.savedStates[name] = state;
                localStorage.setItem('ludi_v1_states', JSON.stringify(this.savedStates));
                document.getElementById('state-name').value = '';
                this.updateDisplay();
            }

            loadState(name) {
                const state = this.savedStates[name];
                this.hand = state.map(s => {
                    const template = LUDI_MODEL.cards.find(c => c.dim === s.dim && c.val === s.val);
                    return {
                        ...template,
                        instanceId: Math.random().toString(36).substr(2, 9),
                        rotation: s.rotation || 0,
                        isFlipped: s.isFlipped,
                        stackedWith: s.stackedWith || null
                    };
                });
                this.updateDisplay();
            }

            deleteState(name) {
                delete this.savedStates[name];
                localStorage.setItem('ludi_v1_states', JSON.stringify(this.savedStates));
                this.updateDisplay();
            }

            stackCard(childId, parentId) {
                this.hand = this.hand.map(c => c.instanceId === childId ? {...c, stackedWith: parentId} : c);
                this.selectedIndex = null;
                hideStackModal();
                this.updateDisplay();
            }

            unstackCard(id) {
                this.hand = this.hand.map(c => c.instanceId === id ? {...c, stackedWith: null} : c);
                this.updateDisplay();
            }

            selectCard(index) {
                this.selectedIndex = (this.selectedIndex === index) ? null : index;
                this.updateDisplay();
            }

            updateDisplay() {
                const handDiv = document.getElementById('hand');
                handDiv.innerHTML = '';

                this.hand.forEach((card, idx) => {
                    const dimInfo = LUDI_MODEL.dimensions.find(d => d.id === card.dim);
                    const container = document.createElement('div');
                    container.className = 'card-container';

                    if (card.stackedWith) {
                        container.style.marginLeft = "-160px";
                        container.style.marginTop = "40px";
                        container.style.zIndex = idx + 10;
                    }

                    const el = document.createElement('div');
                    el.className = `card ${card.isFlipped ? 'is-flipped' : ''} ${this.selectedIndex === idx ? 'selected' : ''}`;
                    el.style.transform = `rotate(${card.rotation}deg)`;
                    el.onclick = (e) => { e.stopPropagation(); this.selectCard(idx); };

                    const allStatesInSuit = LUDI_MODEL.cards.filter(c => c.dim === card.dim);
                    const dots = allStatesInSuit.map(s => `
                        <div class="pos-dot ${s.val === card.val ? 'active' : ''}"
                             title="${s.label}"
                             onclick="event.stopPropagation(); game.changeCardState('${card.instanceId}', '${card.dim}', ${s.val})">
                        </div>`).join('');

                    el.innerHTML = `
                        <div class="card-back-suit">${dimInfo.suit}</div>
                        <div class="card-content">
                            <div class="card-header">
                                <div class="card-suit">${dimInfo.suit}</div>
                            </div>
                            <div class="card-label">${card.label}</div>
                            <div class="card-desc">${card.desc}</div>
                            <div class="card-position">${dots}</div>
                        </div>
                    `;

                    if (this.selectedIndex === idx) {
                        const menu = document.createElement('div');
                        menu.className = 'card-menu';
                        menu.innerHTML = `
                            <button onclick="event.stopPropagation(); game.updateCard('${card.instanceId}', {isFlipped: !${card.isFlipped}})">FLIP</button>
                            <button onclick="event.stopPropagation(); game.updateCard('${card.instanceId}', {rotation: (game.hand[${idx}].rotation + 90) % 360})">ROTATE 90</button>
                            ${card.stackedWith ?
                                `<button onclick="event.stopPropagation(); game.unstackCard('${card.instanceId}')">UNSTACK</button>` :
                                `<button onclick="event.stopPropagation(); showStackModal('${card.instanceId}')">STACK...</button>`
                            }
                            <button onclick="event.stopPropagation(); game.hand.splice(${idx}, 1); game.updateDisplay();" style="color:red">DISCARD</button>
                            <button onclick="event.stopPropagation(); game.selectCard(null)">CLOSE</button>
                        `;
                        container.appendChild(menu);
                    }
                    container.appendChild(el);
                    handDiv.appendChild(container);
                });

                document.getElementById('hand-status').textContent = `HAND: ${this.hand.length}`;
                document.getElementById('deck-status').textContent = `DECK: ${this.deck.length}`;

                const stateList = document.getElementById('saved-states-list');
                stateList.innerHTML = '';
                Object.keys(this.savedStates).forEach(name => {
                    const chip = document.createElement('div');
                    chip.className = 'state-chip';
                    chip.innerHTML = `
                        <span>${name}</span>
                        <button onclick="game.loadState('${name}')">LOAD</button>
                        <button onclick="game.deleteState('${name}')" style="color:red">X</button>
                    `;
                    stateList.appendChild(chip);
                });
            }
        }

        const game = new LudiEngine();
        document.body.onclick = () => game.selectCard(null);

        function showStackModal(childId) {
            const list = document.getElementById('stack-list');
            list.innerHTML = '';
            game.hand.forEach(card => {
                if (card.instanceId !== childId && !card.stackedWith) {
                    const dimInfo = LUDI_MODEL.dimensions.find(d => d.id === card.dim);
                    const item = document.createElement('div');
                    item.className = 'stack-select-item';
                    item.innerHTML = `<span>${dimInfo.suit}</span> <span>${card.label}</span>`;
                    item.onclick = (e) => { e.stopPropagation(); game.stackCard(childId, card.instanceId); };
                    list.appendChild(item);
                }
            });
            document.getElementById('stack-modal').style.display = 'block';
        }

        function hideStackModal() { document.getElementById('stack-modal').style.display = 'none'; }

        function showSurveyModal() {
            const grid = document.getElementById('survey-grid');
            grid.innerHTML = '';

            LUDI_MODEL.dimensions.forEach(dim => {
                const row = document.createElement('div');
                row.className = 'survey-row';
                row.innerHTML = `<div class="survey-row-title">${dim.suit}: ${dim.question}</div>`;

                const optsCont = document.createElement('div');
                optsCont.className = 'survey-options';

                const cards = LUDI_MODEL.cards.filter(c => c.dim === dim.id);
                cards.forEach(c => {
                    const isActive = game.surveyChoices[dim.id] === c.val;
                    const opt = document.createElement('div');
                    opt.className = `survey-option ${isActive ? 'active' : ''}`;
                    opt.innerHTML = `
                        <div class="survey-option-label">${c.label}</div>
                        <div class="survey-option-desc">${c.desc}</div>
                    `;
                    opt.onclick = () => {
                        if (isActive) {
                            delete game.surveyChoices[dim.id];
                        } else {
                            game.surveyChoices[dim.id] = c.val;
                        }
                        showSurveyModal();
                    };
                    optsCont.appendChild(opt);
                });

                row.appendChild(optsCont);
                grid.appendChild(row);
            });

            document.getElementById('survey-modal').style.display = 'block';
        }

        function hideSurveyModal() { document.getElementById('survey-modal').style.display = 'none'; }

        function showAboutModal() { document.getElementById('about-modal').style.display = 'block'; }
        function hideAboutModal() { document.getElementById('about-modal').style.display = 'none'; }
    </script>
</body>
</html>
